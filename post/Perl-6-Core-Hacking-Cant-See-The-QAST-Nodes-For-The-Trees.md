%% title: Perl 6 Core Hacking: Can't See The QAST Nodes For The Trees
%% date: 2018-01-26
%% desc: Overview of "Q" Abstract Syntax Trees
%% draft: True

Over the past month, I spent some time in Rakudo's QAST land writing a few
optimizations, fixing bugs involving warnings, as well as squashing a monster
hive of 10 thunk scoping bugs with a single commit. In today's article,
we'll go over that last feat in detail, as well as learn what QAST is and how
to work with it.

# PART I: The QAST

QAST stands for *"Q" Abstract Syntax Tree*. The "Q" is there because it's
one-after "P", and "P" used to be there to stand for *"Parrot"*, the name of
an earlier, experimental Perl 6 implementation. Let's see what QAST is all
about!

## Dumping QAST

Every Rakudo Perl 6 program
compiles down to a tree of QAST nodes and you can dump that tree if you specify
`--target=ast` or `--target=optimize` command line option to `perl6` when
compiling a program or a module:

```
    $ perl6 --target=ast -e 'say "Hello, World!"'
    [...]
    - QAST::Op(call &say) <sunk> :statement_id<?> say \"Hello, World!\"
      - QAST::Want <wanted> Hello, World!
        - QAST::WVal(Str)
        - Ss
        - QAST::SVal(Hello, World!)
    [...]
```

The difference between the `--target=ast` and `--target=optimize` is that
the former shows the QAST tree as soon as it has been generated, while
the later shows the QAST tree after the static optimizer has had a go at it.

While the command line option gives you the QAST for the entire program, each
[`QAST::Node` object](https://github.com/perl6/nqp/blob/master/src/QAST/Node.nqp) has `.dump` method you can use to dump specific QAST pieces of interest
from within Rakudo's source code.

For example, to examine the QAST generated by the `statement` token, I'd
find [`method statement`](https://github.com/rakudo/rakudo/blob/49dce163e8182ee726cd1e512a03c29551cc16da/src/Perl6/Actions.nqp#L1396) in `src/Perl6/Actions.nqp` and stick `nqp::say('statement QAST: ' ~ $past.dump)` close to the end of
the method.

Since Rakudo's compilation takes a couple of minutes for each go, I like to
key my debug dumps on env variables, like this:

    nqp::atkey(nqp::getenvhash(),'ZZ1') && nqp::say('ZZ1: something or other');
    ...
    nqp::atkey(nqp::getenvhash(),'ZZ2') && nqp::say('ZZ2: something else');

Then, I can execute the compiled `./perl6` as if I didn't add anything, and
enable my dumps by running `ZZ1=1 ./perl6`, `ZZ2=1 ./perl6`, or both dumps
at the same time with `ZZ1=1 ZZ2=1 ./perl6`.

## Viewing QAST

Looking at the output of `--target` dumps in the terminal is sufficient
for a quickie glance at the trees, but for extra assistance you can install
[`CoreHackers::Q` module](https://modules.perl6.org/dist/CoreHackers::Q) that
brings in `q` command line utility.

Simply prefix your regular `perl6` invocation with `q a` or q o` to produce
`--target=ast` and `--target=optimize` QAST dumps respectively. The program
will generate `out.html` file in the current directory:

    $ q a perl6 -e 'say "Hello, World!"'
    $ firefox out.html

Pop open the generated HTML file and reap these benefits:

* Color-coded QAST nodes
* Color hints for sunk nodes
* Ctrl+Click on any node to collapse it
* Muted view of QAST::Want alternatives, makes easier to ignore them

Eventually, I hope to extend this tool and make it more helpful, but at the
time of this writing, that's all it does.

## The QAST Forest

There are four main files in
[rakudo's source](https://github.com/rakudo/rakudo/)
would be the place where you'd expect to be working with QAST
nodes: `src/Perl6/Grammar.nqp`, `src/Perl6/Actions.nqp`, `src/Perl6/World.nqp`,
and `src/Perl6/Optimizer.nqp`. If you're using [`ZScript` utility](https://github.com/zoffixznet/z), you can even run `z q` command to open these
four files in [`Atom` editor](https://github.com/perl6/Atom-as-a-Perl6-IDE).

`Grammar.nqp` is the Perl 6 grammar. `Actions.nqp` are the actions for it.
`World.nqp` contains all sorts of helpful routines used by both `Grammar.nqp`
and `Actions.nqp` (the `$*W` dynamic variable contains a `Perl6::World`
object). Lastly, `Optimizer.nqp` contains Rakudo's static optimizer.

The root (of all evil) is the [`QAST::Node` object](https://github.com/perl6/nqp/blob/master/src/QAST/Node.nqp), with all the other QAST nodes
being its subclasses. Let's review some of the popular ones:

### `QAST::Op`

`QAST::Op` nodes are the workhorse of the QAST world. The `:op` named argument
specifies the name of an [NQP op](https://github.com/perl6/nqp/blob/master/docs/ops.markdown) or the name of a [Rakudo's NQP
extension op](https://github.com/rakudo/rakudo/blob/master/docs/ops.markdown)
and its children are the arguments:

Here's a `say` op printing a string value:

    QAST::Op.new: :op<say>,
      QAST::SVal.new: :value('Hello, World!');

And here's a QAST node for a `call` op that calls to Perl 6's `infix:<+>`
operator; notice how the name of the routine we call is given via `:name` named
argument:

    QAST::Op.new: :op<call>, :name('&infix:<+>'),
      QAST::IVal.new( :value(2)),
      QAST::IVal.new: :value(2)

### `QAST::*Val`

The `QAST::SVal`, `QAST::IVal`, `QAST::NVal`, and `QAST::WVal` nodes, specify
string, integer, float, and "World" object values respectively. The first three
are the "unboxed" raw values, while World objects are everything else, such
as [`DateTime`](https://docs.perl6.org/type/DateTime),
[`Block`](https://docs.perl6.org/type/Block), or
[`Str`](https://docs.perl6.org/type/Block) objects.

### `QAST::Want`

Some of the objects can be represented by multiple `QAST::*Val` nodes, where
the most appropriate value is used depending on what is *wanted* in the
current context. `QAST::Want` node contains these alternatives, interleaved
with string markers indicating what those alternatives are.

For example, numeric `42` in Perl 6 could be needed as an object
to call some method on, or as a raw value to be assigned to a native
`int` attribute. The `QAST::Want` node would look like this:

    QAST::Want.new:
      QAST::WVal.new(:value($Int-obj))),
      'Ii',
      QAST::IVal.new: :value(42)

The `$Int-obj` above would contain an instance of
[`Int` type](https://docs.perl6.org/type/Int) with value set to `42`. The
`Ii` marker indicates the following alternative is an integer value and we
provide a `QAST::IVal` object containing it. The other possible markers are
`Ss` (string)`, `Nn` (float), and `v` (void context) alternatives.

When these nodes are later converted to bytecode, the most appropriate value
will be selected, with the first child being the "default" value, to be used
when none of the available alternatives make the cut.

### `QAST::Var`

These nodes are used for variables and parameters. The `:name` named argument
specifies the name of the variable and `:scope` its scope:

    QAST::Op.new: :op('bind'),
      QAST::Var.new(:name<$x>, :scope<lexical>, :decl<var>, :returns(int)),
      QAST::IVal.new: :value(0)

The `:decl` named arg is present to indicate where this variable is declared
(when it's absent, we simply reference the variable) and its value dictates
what sort of variable it is: `var` for variables, `param` for routine
parameters. Several other `:decl` types, as well as optional arguments
specifying additional configuration of the variable exist. You can find them
discussed in [the QAST
documentation](https://github.com/perl6/nqp/blob/master/docs/qast.markdown#qastvar)

### `QAST::Stmt` / `QAST::Stmts`

These are statement grouping constructs. For example, here, the truthy branch
of an `nqp::if` is three `nqp::say` statements, all grouped inside
`QAST::Stmts`:

    QAST::Op.new: :op<if>,
      QAST::IVal.new(:value(42)),
      QAST::Stmts.new(
        QAST::Op.new( :op<say>, QAST::SVal.new: :value<foo>),
        QAST::Op.new( :op<say>, QAST::SVal.new: :value<bar>),
        QAST::Op.new: :op<say>, QAST::SVal.new: :value<ber>),
      QAST::Op.new: :op<say>, QAST::SVal.new: :value<meow>,

The singular `QAST::Stmt` is similar. The difference is it
marks a register allocation boundary, beyond which, any temporaries are
free to be reused. When used correctly, this alternative can result in better
code generation.

### `QAST::Block`

This node is both a unit of invocation and a unit of lexical scoping. For
example, code `sub foo { say "hello" }` might compile to a `QAST::Block`
like this:

    Block (:cuid(1)) <wanted> :IN_DECL<sub> { say \"hello\" }
    [...]
      Stmts <wanted> say \"hello\"
        Stmt <wanted final> say \"hello\"
          Want <wanted>
            Op (call &say) <wanted> :statement_id<?> say \"hello\"
              Want <wanted> hello
                WVal (Str)
                - Ss
                SVal (hello)
            - v
            Op (p6sink)
              Op (call &say) <wanted> :statement_id<?> say \"hello\"
                Want <wanted> hello
                  WVal (Str)
                  - Ss
                  SVal (hello)
    [...]

Each block demarcates a lexical scope boundary—this detail come into play
in Part II of this article, when we'll be going over a bug fix.

### Others

A few more QAST nodes exist. They're out of scope of this article, but
you may wish to read [the documentation](https://github.com/perl6/nqp/blob/master/docs/qast.markdown) or, since some of them are
do not appear in those docs, go straight
[to the source](https://github.com/perl6/nqp/tree/master/src/QAST).

## Executing QAST Trees

Having a decent familarity with
[nqp ops](https://github.com/perl6/nqp/blob/master/docs/ops.markdown)
(as well as [Rakudo's nqp extensions](https://github.com/rakudo/rakudo/blob/master/docs/ops.markdown)) is helpful when working with
QAST. A sharp eye would notice in QAST dumps that `QAST::Op` nodes correspond
to `nqp::*` op calls, where `:op` named argument specifies the name of the
op.

When writing large QAST trees, it's handy to write them down using pure NQP
ops. Let's look at a simplified example:

    nqp::say('Hello, World!');

We have an NQP op, so we'll start with `QAST::Op` node, using `'say'` as the
value for `:op`. The op takes a single argument: a string to print, so we'll
give it a single `QAST::SVal` node, with the string we want to print as
`:value`:

    QAST::Op.new(:op('say'),
      QAST::SVal.new(:value('Hello, World!')));

I find it easier to track the tree's nesting by using parentheses
only when necessary,
using [colon method call](https://docs.perl6.org/language/syntax#Precedence_Drop) syntax whenever possible:

    QAST::Op.new: :op<say>,
      QAST::SVal.new: :value('Hello, World!');

If a `.new` is followed by a colon, there aren't any
more nodes on the same level. If `.new` is followed by an opening parentheses,
there are more sister nodes yet to come.

Due to Rakudo's lengthy compilation, it can be handy to execute your QAST tree
without having to stick it into `src/Perl6/Actions.nqp` or similar file first.
To some extent, it's possible to do that with a regular Perl 6 program. We'll
simply access `Perl6::World` object in `$*W` variable inside a `BEGIN` block
where it still exists, and call `.compile_time_evaluate` method, giving it
an empty param as the first positional (it expects a `Match` object for
the tree) and our QAST tree as the second positional:

    use QAST:from<NQP>;
    BEGIN $*W.compile_time_evaluate: $,
      QAST::Op.new: :op<say>,
        QAST::SVal.new: :value('Hello, World!');

The one caveat with this method is we're using full-blown Perl 6 language,
whereas in `src/Perl6/Actions.nqp` and related files, as `.nqp` extension
suggests, we're using NQP language only. Keep an eye out for strange
explosions; it's possible your QAST tree that explodes in Perl 6 will compile
just fine in the land of pure NQP.

## Mutating QAST Trees

A handy thing to do with QAST node objects is to mutate them into something
better. That's essentially all the static optimizer in
`src/Perl6/Optimizer.nqp` does. Named arguments can be mutated by calling
them as methods and providing a value. For example, `$qast.op('callstatic')`
will change `:op` type from whatever it is to `callstatic`. Positional
arguments can be altered by re-assignment to a positional index, as well
as `shift`, `push`, `unshift`, `pop` operations performed either via method
calls with those names or `nqp::` ops. Some nodes also support `nqp::elems`
calls on them, which is slightly faster than the generic patter of `+@($qast)`
to find out the number of children a node contains.

As an exercise, let's write a small optimization: some operations, like
`$foo < $bar < $ber` compile to `nqp::chain` ops. This is the case even if
we have only two children, such as `$foo < $bar`. In such cases, rewriting
the op to be `nqp::call` has performance advantages: not only `nqp::call`
on its own is a little bit faster than `nqp::chain`, the static optimizer knows
how to do further optimizations on `nqp::call` ops.

Let's take a look at what both 2-child and 2+-child `nqp::chain` chains look
like:

    $ perl6 --target=ast -e '2 < 3 < 4; 2 < 3'

The first statement compiled to this (I removed `QAST::Want`s for clarifty):

    - QAST::Op(chain &infix:«<»)  :statement_id<?> <
      - QAST::Op(chain &infix:«<») <wanted> <
        - QAST::IVal(2)
        - QAST::IVal(3)
      - QAST::IVal(4)

And the second one to:

    - QAST::Op(chain &infix:«<»)  :statement_id<?> <
      - QAST::IVal(2)
      - QAST::IVal(3)

Thus, to target our optimization correctly, we need to ensure neither child of
our `chain` op is a `chain` op. In addition, we need to ensure that the
op we're optimizing is *not* itself a child of another `chain` op.

Raking [the code of the optimizer](https://github.com/rakudo/rakudo/blob/master/src/Perl6/Optimizer.nqp), we can spot that
chain depth is already tracked via `$!chain_depth` attribute, so we merely need
to ensure we're at the first link of the chain. The code then becomes:

    $qast.op: 'call'
      if nqp::istype($qast, QAST::Op)
      && $qast.op eq 'chain'
      && $!chain_depth == 1
      && ! (nqp::istype($qast[0], QAST::Op) && $qast[0].op eq 'chain')
      && ! (nqp::istype($qast[1], QAST::Op) && $qast[1].op eq 'chain');

Once we find a `chain` `QAST::Op`, we index into it and use `nqp::istype` to
check the type of kid nodes, and if those happen to be `QAST::Op` nodes,
we ensure the  `:op` parameter is not a `chain` op. If all of the conditions are met, we simply call `.op` method on our node with value `'call'` to convert
it into a `call` op.

We then stick our optimization [early enough into `.visit_op` method of the optimizer](https://github.com/rakudo/rakudo/blob/1ee89b54074e80c0753a120d679c6265bd8d5d1f/src/Perl6/Optimizer.nqp#L1228-L1235) and its later portions will
further optimize our `call`.

A fairly easy and straightforward optimization that can bring a lot of benefit.



# PART II: A Thunk in The Trunk

-------

*Note: it took me three evenings to debug and fix the following tickets. To
learn the solution I tried many dead ends that I won't be covering, to keep
you from getting bored, and instead will instantly jump to conclusions. The
point I'm making is that fixing core bugs is a lot easier than may seem
from reading this article—you just need to be willing to spend some time
on them.*

---------------

Now that we have some familiarity with QAST, let's try to fix a
bug that existed in [Rakudo `v2018.01.30.ga.5.c.2398.cc`](https://github.com/rakudo/rakudo/tree/a5c2398cc744706eb81b3d73b181cb4233c85a17)
and earlier. The ticket in question is
[R#1212](https://github.com/rakudo/rakudo/issues/1212), that shows
the following problem:

    $ perl6 -e 'say <a b c>[$_ xx 2] with 1'

    Use of Nil in string context
      in block  at -e line 1
    Unable to call postcircumfix [ (Any) ] with a type object
    Indexing requires a defined object
      in block <unit> at -e line 1

It looks like the `$_` topical variable inside the indexing brackets fails
to get the value from `with` statement modifier and ends up being undefined.
Sounds like a challenge!

## It's A Hive!

Both `with` and `xx` operator create thunks (thunks are like blocks of code,
without having explicit blocks in the code; this, for example, lets
`rand xx 10` to produce 10 different random values; `rand` is thunked and the
thunk is called for each iteration). This reminded me of some other tickets
I've seen, so I went to [fail.rakudo.party](https://fail.rakudo.party/) and
looked through open tickets for anything that mentioned thunking or wrong
scoping.

I ended up with a list of 7 tickets, and with the help of dogbert++ later
increased the number to 9, which with the original Issue gives us a total
of 10 different manifestations of a bug. The other tickets are
[RT#130575](https://rt.perl.org/Ticket/Display.html?id=130575),
[RT#132337](https://rt.perl.org/Ticket/Display.html?id=132337),
[RT#131548](https://rt.perl.org/Ticket/Display.html?id=131548),
[RT#132211](https://rt.perl.org/Ticket/Display.html?id=132211),
[RT#126569](https://rt.perl.org/Ticket/Display.html?id=126569),
[RT#128054](https://rt.perl.org/Ticket/Display.html?id=128054),
[RT#126413](https://rt.perl.org/Ticket/Display.html?id=126413),
[RT#126984](https://rt.perl.org/Ticket/Display.html?id=126984), and
[RT#132172](https://rt.perl.org/Ticket/Display.html?id=132172).
Quite a bug hive!

## Test It Out

The starting point here is to cover each manifestation of the bug with a test.
Make all the test pass and you know you've fixed the bug, plus you already
have something to place into [roast](https://github.com/perl6/roast/), to
cover the tickets. My tests ended up looking like this, where I've used
[`gather`/`take`](https://docs.perl6.org/syntax/gather%20take) duo to capture
what the tickets' code printed to the screen:

    use Test;
    plan 1;
    subtest 'thunking closure scoping' => {
        plan 10;

        # https://github.com/rakudo/rakudo/issues/1212
        is-deeply <a b c>[$_ xx 2], <b b>.Seq, 'xx inside `with`' with 1;

        # RT #130575
        is-deeply gather {
            sub itcavuc ($c) { try {take $c} andthen 42 };
            itcavuc $_ for 2, 4, 6;
        }, (2, 4, 6).Seq, 'try with block and andthen';

        # RT #132337
        is-deeply gather {
            sub foo ($str) { { take $str }() orelse Nil }
            foo "cc"; foo "dd";
        }, <cc dd>.Seq, 'block in a sub with orelse';

        # RT #131548
        is-deeply gather for ^7 {
            my $x = 1;
            1 andthen $x.take andthen $x = 2 andthen $x = 3 andthen $x = 4;
        }, 1 xx 7, 'loop + lexical variable plus chain of andthens';

        # RT #132211
        is-deeply gather for <a b c> { $^v.uc andthen $v.take orelse .say },
            <a b c>.Seq, 'loop + andthen + orelse';

        # RT #126569
        is-deeply gather { (.take xx 10) given 42 }, 42 xx 10,
            'parentheses + xx + given';

        # RT #128054
        is-deeply gather { take ("{$_}") for <aa bb> }, <aa bb>.Seq,
            'postfix for + take + block in a string';

        # RT #126413
        is-deeply gather { take (* + $_)(32) given 10 }, 42.Seq,
            'given + whatever code closure execution';

        # RT #126984
        is-deeply gather {
            sub foo($x) { (* ~ $x)($_).take given $x }; foo(1); foo(2)
        }, ("11", "22").Seq, 'sub + given + whatevercode closure execution';

        # RT #132172
        is-deeply gather { sub {
            my $ver =.lines.uc with "totally-not-there".IO.open
                orelse "meow {$_ ~~ Failure}".take and return 42;
        }() }, 'meow True'.Seq, 'sub with `with` + orelse + block interpolation';
    }

When I brought up the first bug in [our dev
channel](https://webchat.freenode.net/?channels=#perl6-dev), jnthn++ pointed
out that such bugs are often due to mis-scoped blocks, as `p6capturelex`
op that's involved needs to be called in the immediate outer of the block
it references.

Looking through the tickets, I also spotted skids++'s note that changing
a conditional for `statement_id` in block migrator fixed one of the tickets.
This wasn't the full story, as the many still-failing tests showed, but it
was a good start.

## What's Your Problem?

In order to find the best solution for a bug, it's important to understand
what exactly is the problem. We know mis-scoped blocks are the cause of the
bug, so lets grab each of our tests, dump their QAST (`--target=ast`), and
write out *how* mis-scoped the blocks are.

To make it easier to match the `QAST::Block`s with the `QAST::WVal`s
referencing them, I [made a modification](https://github.com/perl6/nqp/commit/0264b237930f426f4cba744c55f10813869ac40b) to `QAST::Node.dump` to include CUID numbers and `statement_id` annotations in the dumps.

Going through mosts of the buggy code chunks, we have these results:

    is-deeply <a b c>[$_ xx 2], <b b>.Seq, 'xx inside `with`' with 1;
    # QAST for `xx` is ALONGSIDE RHS `andthen` thunk, but needs to be INSIDE

    is-deeply gather {
        sub itcavuc ($c) { try {take $c} andthen 42 };
        itcavuc $_ for 2, 4, 6;
    }, (2, 4, 6).Seq, 'try with block and andthen';
    # QAST for try block is INSIDE RHS `andthen` thunk, but needs to be ALONGSIDE

    is-deeply gather {
        sub foo ($str) { { take $str }() orelse Nil }
        foo "cc"; foo "dd";
    }, <cc dd>.Seq, 'block in a sub with orelse';
    # QAST for block is INSIDE RHS `andthen` thunk, but needs to be ALONGSIDE

    is-deeply gather for ^7 {
        my $x = 1;
        1 andthen $x.take andthen $x = 2 andthen $x = 3 andthen $x = 4;
    }, 1 xx 7, 'loop + lexical variable plus chain of andthens';
    # each andthen thunk is nested inside the previous one, but all need to be
    # ALONGSIDE each other

    is-deeply gather for <a b c> { $^v.uc andthen $v.take orelse .say },
        <a b c>.Seq, 'loop + andthen + orelse';
    # andthen's block is INSIDE orelse's but needs to be ALONGSIDE each other

    is-deeply gather { (.take xx 10) given 42 }, 42 xx 10,
        'parentheses + xx + given';
    # .take thunk is ALONGSIDE given's thunk, but needs to be INSIDE of it

    is-deeply gather { take ("{$_}") for <aa bb> }, <aa bb>.Seq,
        'postfix for + take + block in a string';
    # the $_ is ALONGSIDE `for`'s thunk, but needs to be INSIDE

    is-deeply gather { take (* + $_)(32) given 10 }, 42.Seq,
        'given + whatever code closure execution';
    # the WhateverCode ain't got no statement_id and is ALONGSIDE given
    # block but needs to be INSIDE of it

So far, we can see a couple of patterns:

1) [`xx`](https://docs.perl6.org/routine/xx) and
    [`WhateverCode`](https://docs.perl6.org/type/WhateverCode) thunks don't
    get migrated, even though they should
2) [`andthen`](https://docs.perl6.org/routine/andthen) thunks get migrated,
    even though they shouldn't

The first one is fairly straightforward. Looking at the QAST dump, we see
`xx` thunk has a higher `statement_id` than the block it was meant to be in.
This is what skids++'s hint addresses, so we'll
change [the `statement_id` conditional](https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9196) from
`==` to `>=` to look for statement IDs higher than our current one as well,
since those would be from any substatements, such as our `xx` inside the
positional indexing operator:

    ($b.ann('statement_id') // -1) >= $migrate_stmt_id

The cause is the same for the `WhateverCode` case, so we'll just annotate
the generated `QAST::Block` with the statement ID. Some basic detective work
gives us [the location where that node is created](https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9574): we search `src/Perl6/Actions.nqp` for word `"whatever"` until we spot
`whatever_curry` method and in its guts we find the `QAST::Block` we want. For
the statement ID, we'll grep the source for `statement_id`:

    $ grep -FIRn 'statement_id' src/Perl6/
    src/Perl6/Actions.nqp:1497:            $past.annotate('statement_id', $id);
    src/Perl6/Actions.nqp:2326:                $_.annotate('statement_id', $*STATEMENT_ID);
    src/Perl6/Actions.nqp:2488:                -> $b { ($b.ann('statement_id') // -1) == $stmt.ann('statement_id') });
    src/Perl6/Actions.nqp:9235:                && ($b.ann('statement_id') // -1) >= $migrate_stmt_id
    src/Perl6/Actions.nqp:9616:            ).annotate_self: 'statement_id', $*STATEMENT_ID;
    src/Perl6/World.nqp:256:            $pad.annotate('statement_id', $*STATEMENT_ID);

From the output, we can see the ID is stored in `$*STATEMENT_ID` dynamic
variable, so we'll use that for our annotation on the `WhateverCode`:

    my $block := QAST::Block.new(
        QAST::Stmts.new(), $past
    ).annotate_self: 'statement_id', $*STATEMENT_ID;

Let's compile and run our bug tests. If you're using
[ZScript](https://github.com/zoffixznet/z), you can re-compile Rakudo
by running `z` command with no arguments:

    $ z
    [...]
    $ ./perl6 bug-tests.t
    1..1
        1..10
        ok 1 - xx inside `with`
        not ok 2 - try with block and andthen
        # Failed test 'try with block and andthen'
        # at /home/zoffix/R/bug-tests.t line 10
        # expected: $(2, 4, 6)
        #      got: $(2, 2, 4)
        not ok 3 - block in a sub with orelse
        # Failed test 'block in a sub with orelse'
        # at /home/zoffix/R/bug-tests.t line 16
        # expected: $("cc", "dd")
        #      got: $("cc", "cc")
        not ok 4 - loop + lexical variable plus chain of andthens
        # Failed test 'loop + lexical variable plus chain of andthens'
        # at /home/zoffix/R/bug-tests.t line 22
        # expected: $(1, 1, 1, 1, 1, 1, 1)
        #      got: $(1, 4, 3, 3, 3, 3, 3)
        not ok 5 - loop + andthen + orelse
        # Failed test 'loop + andthen + orelse'
        # at /home/zoffix/R/bug-tests.t line 28
        # expected: $("a", "b", "c")
        #      got: $("a", "a", "a")
        ok 6 - parentheses + xx + given
        ok 7 - postfix for + take + block in a string
        ok 8 - given + whatever code closure execution
        ok 9 - sub + given + whatevercode closure execution
        not ok 10 - sub with `with` + orelse + block interpolation
        # Failed test 'sub with `with` + orelse + block interpolation'
        # at /home/zoffix/R/bug-tests.t line 49
        # expected: $("meow True",)
        #      got: $("meow False",)
        # Looks like you failed 5 tests of 10
    not ok 1 - thunking closure scoping
    # Failed test 'thunking closure scoping'
    # at /home/zoffix/R/bug-tests.t line 3
    # Looks like you failed 1 test of 1

Looks like that fixed half the issues. Pretty good!

## Extra Debugging

Let's now look at the remaining failures and figure out why block migration
isn't how we want it in those cases. To assists with our sleuthing efforts,
let's make a couple of changes to produce more debugging info.

First, let's modify [`QAST::Node.dump` method in NQP's repo](https://github.com/perl6/nqp/blob/d71bd7334c5c9363d49ddf20645e6041af15fa41/src/QAST/Node.nqp#L166)
to dump the value of `in_stmt_mod` annotation:

    if $k eq 'IN_DECL' || $k eq 'BY' || $k eq 'statement_id'
    || $k eq 'in_stmt_mod' {
        ...

Next, let's go to [`sub migrate_blocks` in `Actions.nqp`](https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L6535-L6560) and add a bunch of debug dumps inside all of the conditionals.
This will let us track when a block is compared and to see whether migration
occurs. As mentioned earlier, I like to key my dumps on env vars using
`nqp::getenvhash` op, so after modifications my `migrate_blocks` routine
looks like this; note the use of `.dump` method to dump QAST node guts
(tip: `.dump` method exists on grammar match objects as well!):

    sub migrate_blocks($from, $to, $predicate?) {
        my @decls := @($from[0]);
        my int $n := nqp::elems(@decls);
        my int $i := 0;
        while $i < $n {
            my $decl := @decls[$i];
            if nqp::istype($decl, QAST::Block) {
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: -----------------');
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: trying to grab ' ~ $decl.dump);
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: to move to ' ~ $to.dump);
                if !$predicate || $predicate($decl) {
                    nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: grabbed');
                    $to[0].push($decl);
                    @decls[$i] := QAST::Op.new( :op('null') );
                }
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: -----------------');
            }
            elsif (nqp::istype($decl, QAST::Stmt) || nqp::istype($decl, QAST::Stmts)) &&
                  nqp::istype($decl[0], QAST::Block) {
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: -----------------');
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: trying to grab ' ~ $decl[0].dump);
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: to move to ' ~ $to.dump);
                if !$predicate || $predicate($decl[0]) {
                    nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: grabbed');
                    $to[0].push($decl[0]);
                    $decl[0] := QAST::Op.new( :op('null') );
                }
                nqp::atkey(nqp::getenvhash(),'ZZ') && nqp::say('ZZ1: -----------------');
            }
            elsif nqp::istype($decl, QAST::Var) && $predicate && $predicate($decl) {
                $to[0].push($decl);
                @decls[$i] := QAST::Op.new( :op('null') );
            }
            $i++;
        }
    }

After making the changes, we need to recompile both NQP and Rakudo. With
[ZScript](https://github.com/zoffixznet/z), we can just run `z n` to do that:

    $ z n
    [...]

Now, we'll grab the first failing code and take a look at its QAST. I'm
going to use [`CoreHackers::Q` tool](https://modules.perl6.org/dist/CoreHackers::Q)

    $ q a ./perl6 -e '
        sub itcavuc ($c) { try {say $c} andthen 42 };
        itcavuc $_ for 2, 4, 6;'
    $ firefox out.html

We can see that our buggy `say` call lives in `QAST::Block` with `cuid 1`,
which gets called from within `QAST::Block` with `cuid 3`, but is actually
located within `QAST::Block` with `cuid 2`:

    - QAST::Block(:cuid(3)) <wanted> :statement_id<1>
            :count<?> :signatured<?> :IN_DECL<sub>
            :in_stmt_mod<0> :code_object<?>
            :outer<?> { try {say $c} andthen 42 }
        [...]
            - QAST::Block(:cuid(2)) <wanted> :statement_id<2>
                    :count<?> :in_stmt_mod<0> :code_object<?> :outer<?>
                [...]
                - QAST::Block(:cuid(1)) <wanted> :statement_id<2>
                        :IN_DECL<> :in_stmt_mod<0> :code_object<?>
                        :also_uses<?> :outer<?> {say $c}
                    [...]
                    - QAST::Op(call &say)  say $c
        [...]
        - QAST::Op(p6typecheckrv)
            [...]
            - QAST::WVal(Block :cuid(1))

Looks like `cuid 2` block steals our `cuid 1` block. Let's enable the
debug env var and look at the dumps to see why exactly:

    $ ZZ=1 ./perl6 -e '
        sub itcavuc ($c) { try {say $c} andthen 42 };
        itcavuc $_ for 2, 4, 6;'

    ZZ1: -----------------
    ZZ1: trying to grab - QAST::Block(:cuid(1)) <wanted>
        :statement_id<2> :IN_DECL<> :in_stmt_mod<0> :code_object<?>
        :also_uses<?> :outer<?> {say $c}
    [...]

    ZZ1: to move to - QAST::Block  :statement_id<2>
        :in_stmt_mod<0> :outer<?>

    ZZ1: grabbed
    ZZ1: -----------------

We can see the theft in progress. Let's take a look at our [migration
predicate](https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Perl6/Actions.nqp#L9196)
again:

    ! $b.ann('in_stmt_mod')
    && ($b.ann('statement_id') // -1) >= $migrate_stmt_id

In the dump we can see `in_stmt_mod` is false. Were it set to a true value,
the block would not be migrated—exactly what we're trying to accomplish.
Let's investigate the `in_stmt_mod` annotation, to see when it gets set:

    $ G 'in_stmt_mod' src/Perl6/Actions.nqp
    2327:                $_.annotate('in_stmt_mod', $*IN_STMT_MOD);
    9206:                !$b.ann('in_stmt_mod') && ($b.ann('statement_id') // -1) >= $migrate_stmt_id

    $ G '$*IN_STMT_MOD' src/Perl6/Grammar.nqp
    1200:        :my $*IN_STMT_MOD := 0;                    # are we inside a statement modifier?
    1328:        :my $*IN_STMT_MOD := 0;
    1338:        | <EXPR> :dba('statement end') { $*IN_STMT_MOD := 1 }

Looks like it's a marker for statement modifier conditions. Statement modifiers
have a lot of relevance to our `andthen` thunks, because `$foo with $bar` gets
turned into `$bar andthen $foo` during parsing. Since, as we can see in
`src/Perl6/Grammar.nqp`, `in_stmt_mod` annotation gets set for `with`
statement modifiers, we can hypothesize that if we turn
our buggy `andthen` into a `with`, the bug will disappear:


    $ ./perl6 -e 'sub itcavuc ($c) { 42 with try {say $c} };
        itcavuc $_ for 2, 4, 6;'
    2
    4
    6

And indeed it does!